---
layout: post
title:  "JS Ninja: Combining Generators and Promises"
date:   2017-06-12 12:00:01-0400
---

In this section, we’ll combine generators (and their capability to pause and resume their execution) with promises, in order to achieve more elegant async code. We’ll use the example of a functionality that enables users to get details of the highest rated mission done by the most popular ninja.

The data representing the ninjas, the summaries of their missions, as well as the details of the missions are stored on a remote server, encoded in JSON.

All of these subtasks are long-running and mutually dependent. If we were to implement them in a synchronous fashion, we’d get the following straightforward code:

    try {
      const ninjas = syncGetJSON(“data/ninjas.json”);
      const missions = syncGetJSON(“ninjas[0].missionsUrl”);
      const missionDetails = syncGetJSON(missions[0].detailsUrl);
      //Study the mission description
    } catch (e) {
      //Oh no, we weren’t able to get the mission details
    }

Although this code is great for its simplicity and error handling, it blocks the UI.

Ideally, we’d like to change this code so that no blocking occurs during a long-running task.

One way of doing this is by combining generators and promises. 

As we know, yielding from a generator suspends the execution of the generator without blocking. To wake up the generator and continue its execution, we have to call the next method on the generator’s iterator. 

Promises on the other hand, allow us to specify a callback that will be triggered in case we were able to obtain the promised value, and a callback that will be triggered in case an error occurred.

The idea, then, is to combine generators and promises in the following way: 
  1. We put the code that uses asynchronous tasks in a generator, and we execute that generator function.
  2. When we reach a point in the generator execution that calls an asynchronous task, we create a promise that represents the value of that asynchronous task.
    … Because we have no idea when that promise will be resolved (or even if it will be resolved), at this point of generator execution, we yield from the generator, so that we don’t cause blocking.
  3. After a while, when the promise gets settled, we continue the execution of our generator by calling the iterator’s next method.
  4. We do this as many times as necessary.

Here’s a practical example: 

//below: The function using asynchronous results should be able to pause while waiting for results. Notice the function*. We’re using generators!

    async(function*(){
      try {

      //below: Yield on each asynchronous task: 

        const ninjas = yield getJSON(“data/ninjas.json”);
        const missions = yield getJSON(ninjas[0].missionUrl);
        const missionDescription = yield getJSON(missions[0].detailsUrl);
        // Study the mission details

      //below: we can still use all standard language constructs such as try-catch statements or loops

      } catch (e) {
        //Oh No, we weren’t able to get the mission details.
      }
    });

//below: defines a helper function that will control our generator:

    function async(generator) {
      var iterator = generator();   

      //^^ creates an iterator through which we’ll control the generator
      //below: defines the function that will handle each value generated by the generator

      function handle(iteratorResult) {
        if (iteratorResult.done){ return; }

        //^^ Stops when the generator has no more results   

        const iteratorValue = iteratorResult.value;

        if (iteratorValue instanceof Promise) {
          iteratorValue.then(res => handle(iterator.next(res))
              .catch( err => iterator.throw(err));
        }

        //^^ if the generated value is a promise, register a success and a failure callback. This is the asynchronous part. If the promise succeeds, great, resume the generator and send in the promised value. If there’s an error, throw an exception to the generator.
      }

      //below: restarts the generator execution
      try {
        handle(iterator.next());
      } catch (e) {
        iterator.throw(e);
      }
      
    }

This end result combines the advantages of synchronous and asynchronous code. 

From the synchronous code, we have the ease of understanding, and the ability to use all standard control-flow and exception handling mechanisms such as loops and try-catch statements.

From asynchronous code, we get the nonblocking nature; the execution of our application isn’t blocked while waiting for long-running asynchronous tasks.
